{
  "Event-Driven Programming": {
    "Beginner": [
      {
        "id": 1,
        "question": "ما هو Event؟",
        "options": ["دالة", "حدث", "كائن", "متغير"],
        "correct_index": 1,
        "explanation": "في البرمجة القائمة على الأحداث، الـ Event هو شيء يحدث في النظام مثل ضغط زر أو تحريك الفأرة أو إدخال بيانات من المستخدم، لذلك الخيار «حدث» هو التعريف الصحيح."
      },
      {
        "id": 2,
        "question": "متى يعمل Event Handler؟",
        "options": ["عند بدء البرنامج", "عند حدوث حدث", "عند إنهاء البرنامج", "عند تعريف المتغيرات"],
        "correct_index": 1,
        "explanation": "الـ Event Handler هو الكود الذي يتم تنفيذه عندما يحدث حدث معيّن، لذلك يعمل عند حدوث الحدث المرتبط به وليس عند بدء أو إنهاء البرنامج."
      },
      {
        "id": 3,
        "question": "ما وظيفة Event Loop؟",
        "options": ["تنفيذ البرنامج مرة واحدة", "انتظار الأحداث وتنفيذها", "تخزين البيانات", "عرض الواجهة"],
        "correct_index": 1,
        "explanation": "وظيفة الـ Event Loop هي إبقاء البرنامج في حالة تشغيل وانتظار مستمر للأحداث، ثم استدعاء معالجات هذه الأحداث (Event Handlers) وتنفيذها عند وقوعها."
      },
      {
        "id": 4,
        "question": "الضغط على زر في التطبيق يمثل:",
        "options": ["Class", "Event", "Method", "Variable"],
        "correct_index": 1,
        "explanation": "الضغط على زر هو تفاعل من المستخدم مع الواجهة، ويُعد حدثًا (Event) يتم التقاطه ومعالجته في البرمجة القائمة على الأحداث."
      },
      {
        "id": 5,
        "question": "أي تطبيق يعتمد على Event-Driven Programming؟",
        "options": ["برنامج حسابي بسيط", "تطبيق واجهة تفاعلية", "ملف نصي", "برنامج خطي"],
        "correct_index": 1,
        "explanation": "التطبيقات ذات الواجهة التفاعلية (مثل تطبيقات النوافذ أو التطبيقات الرسومية) تعتمد على البرمجة القائمة على الأحداث لأنها تستجيب لضغط الأزرار وحركات الماوس وإدخال المستخدم."
      },
      {
        "id": 6,
        "question": "أي مما يلي يُعد Event؟",
        "options": ["تعريف متغير", "تحريك الماوس", "كتابة دالة", "إنهاء البرنامج"],
        "correct_index": 1,
        "explanation": "تحريك الماوس يمثل تفاعلًا يحدث أثناء تشغيل البرنامج، ويمكن التقاطه كحدث (Event)، بينما تعريف متغير أو كتابة دالة هي أجزاء من الكود وليست أحداثًا."
      },
      {
        "id": 7,
        "question": "Event Handler هو:",
        "options": ["حدث", "كود يستجيب لحدث", "حلقة تكرار", "متغير"],
        "correct_index": 1,
        "explanation": "الـ Event Handler هو جزء من الكود يتم تشغيله عندما يحدث حدث معين، لذلك هو «كود يستجيب لحدث» وليس الحدث نفسه."
      },
      {
        "id": 8,
        "question": "لماذا يبقى البرنامج في وضع انتظار؟",
        "options": ["لإنهاء التنفيذ", "لاستقبال الأحداث", "لتخزين البيانات", "لعرض الكود"],
        "correct_index": 1,
        "explanation": "في البرمجة القائمة على الأحداث، يبقى البرنامج في حالة انتظار (Idle) لاستقبال الأحداث من المستخدم أو النظام، وليس بهدف إنهاء التنفيذ أو تخزين البيانات."
      },
      {
        "id": 9,
        "question": "أي نمط يعتمد على تفاعل المستخدم؟",
        "options": ["Procedural", "OOP", "Event-Driven", "Sequential"],
        "correct_index": 2,
        "explanation": "البرمجة القائمة على الأحداث (Event-Driven) تعتمد بشكل أساسي على تفاعل المستخدم مع الواجهة مثل الضغط والتحريك، لذلك هي النمط الأكثر ارتباطًا بتفاعل المستخدم."
      },
      {
        "id": 10,
        "question": "متى يتم تنفيذ الكود في Event-Driven Programming؟",
        "options": ["من أول سطر", "عند حدوث حدث", "بعد انتهاء البرنامج", "عند تعريف المتغير"],
        "correct_index": 1,
        "explanation": "في البرمجة القائمة على الأحداث، لا يُنفّذ الكود بشكل خطي من أول سطر، بل يتم تنفيذ أجزاء معينة من الكود عند حدوث أحداث معيّنة، مثل ضغط زر."
      }
    ],
    "Intermediate": [
      {
        "id": 11,
        "question": "ما دور Event Listener؟",
        "options": ["تنفيذ الكود", "مراقبة الأحداث", "تخزين البيانات", "إيقاف البرنامج"],
        "correct_index": 1,
        "explanation": "الـ Event Listener هو مكوّن يراقب حدوث حدث معيّن، وعند وقوعه يقوم بإبلاغ النظام أو استدعاء الـ Event Handler المناسب، لذلك دوره هو مراقبة الأحداث."
      },
      {
        "id": 12,
        "question": "ما العلاقة بين Event و Event Handler؟",
        "options": ["لا علاقة", "الحدث يشغّل المعالج", "المعالج ينشئ الحدث", "كلاهما نفس الشيء"],
        "correct_index": 1,
        "explanation": "الحدث (Event) هو ما يحدث في النظام، وعند وقوعه يتم تشغيل الـ Event Handler المرتبط به، لذلك الحدث هو الذي يشغّل المعالج وليس العكس."
      },
      {
        "id": 13,
        "question": "لماذا يصعب تتبع التنفيذ في البرامج المعتمدة على الأحداث؟",
        "options": ["لأن الكود قصير", "لأن الأحداث غير متسلسلة", "لعدم وجود دوال", "لأن التنفيذ خطي"],
        "correct_index": 1,
        "explanation": "في البرمجة القائمة على الأحداث، ترتيب تنفيذ الكود يعتمد على تسلسل الأحداث التي قد تحدث بترتيب غير متوقع، مما يجعل تتبع تدفق التنفيذ أصعب مقارنة بالتنفيذ الخطي."
      },
      {
        "id": 14,
        "question": "أي مما يلي يسبب تعقيداً في Event-Driven Programming؟",
        "options": ["حدث واحد", "تعدد الأحداث", "برنامج صغير", "تنفيذ خطي"],
        "correct_index": 1,
        "explanation": "عندما يكون في النظام عدد كبير من الأحداث والمعالجات المرتبطة بها، يصبح من الصعب إدارة العلاقة بينها وتتبع سلوك البرنامج، مما يزيد من التعقيد."
      },
      {
        "id": 15,
        "question": "Event Loop مسؤولة عن:",
        "options": ["إيقاف البرنامج", "الاستماع المستمر للأحداث", "تعريف الكائنات", "تنفيذ الكود مرة واحدة"],
        "correct_index": 1,
        "explanation": "دور الـ Event Loop هو الاستماع المستمر للأحداث أثناء تشغيل البرنامج، وعند حدوث حدث، يتم استدعاء الكود المناسب لمعالجته."
      },
      {
        "id": 16,
        "question": "ما نوع أسلوب التنفيذ في Event-Driven Programming؟",
        "options": ["Bottom-up", "Top-down", "Sequential", "Parallel"],
        "correct_index": 1,
        "explanation": "غالبًا يتم إعداد البرنامج أولاً ثم يبقى في حالة انتظار للأحداث من الأعلى إلى الأسفل (Top-down) من حيث تصميم التدفق العام ثم الاستجابة للأحداث في أي وقت."
      }
    ],
    "Advanced": [
      {
        "id": 17,
        "question": "أي سيناريو غير مناسب لـ Event-Driven Programming؟",
        "options": ["واجهة مستخدم", "نظام تفاعلي", "حسابات متسلسلة", "تطبيق ويب"],
        "correct_index": 2,
        "explanation": "الحسابات المتسلسلة التي تنفّذ خطوات ثابتة واحدة تلو الأخرى لا تستفيد كثيرًا من نموذج الأحداث، بل تناسبها البرمجة الإجرائية ذات التنفيذ الخطي."
      },
      {
        "id": 18,
        "question": "ما التأثير السلبي لكثرة الأحداث؟",
        "options": ["تحسين الأداء", "استهلاك موارد النظام", "تبسيط الكود", "تقليل الذاكرة"],
        "correct_index": 1,
        "explanation": "عند وجود عدد كبير من الأحداث، قد يزداد استهلاك المعالج والذاكرة لمتابعتها والتعامل معها، مما يؤدي إلى استهلاك أكبر لموارد النظام."
      },
      {
        "id": 19,
        "question": "أي نمط برمجي أنسب للتطبيقات التفاعلية؟",
        "options": ["Procedural", "Event-Driven", "Sequential", "None"],
        "correct_index": 1,
        "explanation": "التطبيقات التفاعلية تعتمد على استجابة الواجهة لتصرفات المستخدم، وهذا يتوافق مباشرة مع مبدأ البرمجة القائمة على الأحداث."
      },
      {
        "id": 20,
        "question": "لماذا يحتاج هذا النمط إلى تنظيم جيد؟",
        "options": ["لقلة الأحداث", "لتجنب تعقيد التدفق", "لأنه خطي", "لأنه بسيط"],
        "correct_index": 1,
        "explanation": "بسبب تعدد الأحداث والمعالجات المرتبطة بها، قد يصبح تدفق التنفيذ معقدًا، لذلك يحتاج المصمم إلى تنظيم جيد للكود لتجنب التعقيد والفوضى."
      }
    ]
  },

  "Object-Oriented Programming": {
    "Beginner": [
      {
        "id": 21,
        "question": "ما هو Object؟",
        "options": ["نسخة من Class", "دالة", "حلقة", "متغير"],
        "correct_index": 0,
        "explanation": "في البرمجة كائنية التوجه، الـ Object هو كيان فعلي يتم إنشاؤه من الـ Class ويحتوي على البيانات والسلوكيات المعرفة في هذا الـ Class، لذلك هو «نسخة من Class»."
      },
      {
        "id": 22,
        "question": "ما هو Class؟",
        "options": ["كائن", "قالب لإنشاء الكائنات", "إجراء", "متغير"],
        "correct_index": 1,
        "explanation": "الـ Class هو قالب أو مخطط يتم من خلاله إنشاء الكائنات (Objects)، حيث يعرّف الخصائص والوظائف المشتركة بينها."
      },
      {
        "id": 23,
        "question": "Attribute تمثل:",
        "options": ["سلوك", "خاصية", "حدث", "حلقة"],
        "correct_index": 1,
        "explanation": "الـ Attribute تمثل خاصية من خصائص الكائن، مثل اللون أو الاسم، لذلك هي «خاصية» وليست سلوكًا أو حدثًا."
      },
      {
        "id": 24,
        "question": "Method تمثل:",
        "options": ["خاصية", "سلوك", "متغير", "حدث"],
        "correct_index": 1,
        "explanation": "الـ Method تمثل سلوكًا أو وظيفة يقوم بها الكائن، مثل التحرك أو الطباعة، لذلك هي «سلوك» وليست خاصية ثابتة."
      },
      {
        "id": 25,
        "question": "أي مفهوم يخفي تفاصيل التنفيذ؟",
        "options": ["Inheritance", "Encapsulation", "Polymorphism", "Loop"],
        "correct_index": 1,
        "explanation": "الـ Encapsulation يعني إخفاء تفاصيل تنفيذ الكائن الداخلية وإتاحة واجهة بسيطة للتعامل معه، مما يحمي البيانات ويمنع الوصول غير المسموح."
      },
      {
        "id": 26,
        "question": "أي لغة برمجة تدعم OOP؟",
        "options": ["HTML", "Java", "CSS", "SQL"],
        "correct_index": 1,
        "explanation": "لغة Java هي لغة برمجة كائنية التوجه وتدعم الـ Classes والـ Objects، بينما HTML وCSS وSQL ليست لغات OOP."
      },
      {
        "id": 27,
        "question": "Inheritance تعني:",
        "options": ["نسخ الكود", "توريث الخصائص والوظائف", "إخفاء البيانات", "تنفيذ أوامر"],
        "correct_index": 1,
        "explanation": "الـ Inheritance يسمح لـ Class جديد أن يرث الخصائص والوظائف من Class آخر، مما يسهل إعادة استخدام الكود وتوسيعه."
      },
      {
        "id": 28,
        "question": "Polymorphism تعني:",
        "options": ["سلوك واحد", "أكثر من شكل", "تنفيذ خطي", "حدث"],
        "correct_index": 1,
        "explanation": "الـ Polymorphism يعني إمكانية استخدام نفس الاسم لوظيفة أو عملية تظهر بأكثر من شكل حسب نوع الكائن الذي يستدعيها."
      }
    ],
    "Intermediate": [
      {
        "id": 29,
        "question": "لماذا تعتبر OOP مناسبة للبرامج الكبيرة؟",
        "options": ["تعقيد أقل", "تنظيم أفضل", "كود أقل", "تنفيذ أسرع"],
        "correct_index": 1,
        "explanation": "البرمجة كائنية التوجه تسمح بتقسيم النظام إلى كائنات مترابطة، مما يسهل تنظيم الكود وفهمه وصيانته في البرامج الكبيرة."
      },
      {
        "id": 30,
        "question": "ما نوع أسلوب التنفيذ في OOP؟",
        "options": ["Top-down", "Bottom-up", "Sequential", "Event"],
        "correct_index": 1,
        "explanation": "في OOP يتم بناء النظام من كائنات صغيرة ثم تجميعها في نظام أكبر، وهذا يتوافق مع أسلوب التنفيذ Bottom-up."
      },
      {
        "id": 31,
        "question": "أي مفهوم يعزز أمان البيانات؟",
        "options": ["Loop", "Encapsulation", "Procedure", "Event"],
        "correct_index": 1,
        "explanation": "الـ Encapsulation يحمي البيانات داخل الكائن من الوصول المباشر، ولا يتيح التعديل عليها إلا من خلال واجهة محددة (Methods)، مما يعزز الأمان."
      },
      {
        "id": 32,
        "question": "إعادة استخدام الكود تتم غالباً عبر:",
        "options": ["Inheritance", "Variables", "Loops", "Conditions"],
        "correct_index": 0,
        "explanation": "الـ Inheritance يسمح بإنشاء Class جديد يعتمد على Class موجود، مع إمكانية إضافة أو تعديل بعض السلوكيات، وهذا يشجع إعادة استخدام الكود بدل نسخه."
      }
    ],
    "Advanced": [
      {
        "id": 33,
        "question": "متى تكون OOP غير مناسبة؟",
        "options": ["برنامج صغير جداً", "نظام معقد", "تطبيق كبير", "نظام طويل"],
        "correct_index": 0,
        "explanation": "في البرامج الصغيرة جدًا ذات المتطلبات البسيطة، قد تكون OOP مبالغة وتضيف تعقيدًا لا داعي له مقارنة بالبرمجة الإجرائية."
      },
      {
        "id": 34,
        "question": "أي نمط أسهل للمبتدئين؟",
        "options": ["OOP", "Procedural", "Event-Driven", "None"],
        "correct_index": 1,
        "explanation": "البرمجة الإجرائية تعتمد على تنفيذ الأوامر خطوة بخطوة، وهذا النمط يكون عادة أسهل في الفهم للمبتدئين مقارنة بمفاهيم الكائنات والوراثة في OOP."
      }
    ]
  },

  "Procedural Programming": {
    "Beginner": [
      {
        "id": 35,
        "question": "كيف يتم تنفيذ البرنامج الإجرائي؟",
        "options": ["Random", "Sequential", "Event", "Parallel"],
        "correct_index": 1,
        "explanation": "في البرمجة الإجرائية يتم تنفيذ الأوامر بالتسلسل من سطر إلى آخر، لذلك نمط التنفيذ يكون Sequential وليس عشوائيًا أو معتمدًا على الأحداث."
      },
      {
        "id": 36,
        "question": "ما هي Function؟",
        "options": ["إجراء يعيد قيمة", "متغير", "كائن", "حلقة"],
        "correct_index": 0,
        "explanation": "الـ Function هي مجموعة أوامر تؤدي مهمة معينة وتعيد قيمة كنتيجة، وهذا ما يميزها عن الإجراء الذي قد لا يعيد قيمة."
      },
      {
        "id": 37,
        "question": "Procedure هي:",
        "options": ["تعيد قيمة", "لا تعيد قيمة", "كائن", "حدث"],
        "correct_index": 1,
        "explanation": "الـ Procedure تشبه الـ Function من حيث تنفيذ مجموعة أوامر، لكنها لا تعيد قيمة، لذلك تعتبر إجراءً بلا مخرجات مباشرة."
      },
      {
        "id": 38,
        "question": "من مزايا البرمجة الإجرائية:",
        "options": ["تعقيد", "سهولة التعلم", "تنظيم عالي", "تفاعل"],
        "correct_index": 1,
        "explanation": "البرمجة الإجرائية بسيطة ومباشرة، وتعتمد على تسلسل الأوامر، مما يجعلها سهلة التعلم للمبتدئين."
      },
      {
        "id": 39,
        "question": "من عيوب البرمجة الإجرائية:",
        "options": ["سهولة", "صعوبة التوسعة", "سرعة", "وضوح"],
        "correct_index": 1,
        "explanation": "مع نمو حجم البرنامج الإجرائي يصبح من الصعب توسعته وصيانته، لأن الكود غالبًا يكون متداخلًا وغير منظم للكائنات."
      }
    ],
    "Intermediate": [
      {
        "id": 40,
        "question": "ما نوع أسلوب التنفيذ في Procedural Programming؟",
        "options": ["Bottom-up", "Top-down", "Event", "Parallel"],
        "correct_index": 1,
        "explanation": "البرمجة الإجرائية غالبًا تتبع أسلوب Top-down حيث يتم تقسيم المشكلة الكبيرة إلى أجزاء أصغر، ثم كتابة الأوامر وتنفيذها من الأعلى إلى الأسفل."
      },
      {
        "id": 41,
        "question": "Local Variable يعني:",
        "options": ["متغير عام", "متغير داخل دالة", "حدث", "كائن"],
        "correct_index": 1,
        "explanation": "المتغير المحلي Local Variable هو متغير يُعرّف داخل دالة أو إجراء ولا يمكن الوصول إليه من خارج هذا النطاق."
      },
      {
        "id": 42,
        "question": "Global Variable يعني:",
        "options": ["داخل دالة", "متاح لكل البرنامج", "كائن", "حدث"],
        "correct_index": 1,
        "explanation": "المتغير العام Global Variable يكون معرفًا خارج الدوال ويمكن الوصول إليه من عدة أجزاء في البرنامج، مما يجعله متاحًا على مستوى واسع."
      }
    ],
    "Advanced": [
      {
        "id": 43,
        "question": "لماذا تصعب صيانة البرامج الإجرائية الكبيرة؟",
        "options": ["لقلة المتغيرات", "لتداخل الكود", "لبساطة التنفيذ", "لقلة الأوامر"],
        "correct_index": 1,
        "explanation": "مع زيادة حجم البرنامج الإجرائي، قد تتداخل الأوامر والدوال ويتكرر الكود، مما يجعل فهمه وتعديله وصيانته أمرًا صعبًا."
      },
      {
        "id": 44,
        "question": "أي نمط برمجي أنسب للتطبيقات الكبيرة؟",
        "options": ["Procedural", "OOP", "Sequential", "None"],
        "correct_index": 1,
        "explanation": "البرمجة كائنية التوجه OOP أنسب للتطبيقات الكبيرة لأنها تسمح بتنظيم الكود في كائنات وClasses، مما يسهل التوسعة والصيانة مقارنة بالبرمجة الإجرائية."
      }
    ]
  }
}
